【第四章 存储器管理】

> 王道考研OS课

# 4.1.1内存的基础知识

```mermaid
graph LR
Title(内存的基础知识)--> A(什么是内存 有何作用)
A-->A1(存储单元)
A-->A2(内存地址)
Title-->B(进程运行的基本原理)
B-->B1(指令的工作原理)
B-->B2(逻辑地址VS物理地址)
B-->B3(从写程序道程序运行:编辑-编译-链接-装入)
B-->B4(三种链接方式)
B-->B5(三种装入方式)
```

## 一、什么是内存，内存的作用

> 这里的==内存==指的是都是内存条那个内存，也叫==主存==，速度较快，一般现在电脑都是8G,16G的那个。另一个512G,1TB的那个叫辅存，是硬盘，速度较慢

### 存储单元

辅存的速度较慢，所以需要速度较快的内存和CPU交互，而内存被分为一个个存储单元，每个单元的大小依据计算机的设计而不同。

![image-20221126232225785](./assets/image-20221126232225785.png)

### 补充知识，常用的数量单位

![image-20221126232556054](./assets/image-20221126232556054.png)

## 二、进程的运行原理

### 指令

每个进程在逻辑上有三个部分组成，程序段、数据段、PCB，CPU根据程序段来执行指令

![image-20221126233020900](./assets/image-20221126233020900.png)

### 逻辑地址VS物理地址

简单来说，相对地址(逻辑地址)就是代码在整个代码块里的编号，绝对地址(物理地址)就是在内存里的确切地址，逻辑地址+起始地址就可以得到绝对地址

![image-20221126234916817](./assets/image-20221126234916817.png)

### 从写程序到程序运行的流程

将逻辑地址转化为物理地址，就看装入

![image-20221126235437791](./assets/image-20221126235437791.png)

### 三种装入方式

如图，起始地址为100，但是指令里的地址是逻辑地址，并不对。将逻辑地址转化为物理地址就有三种不同的方法

![image-20221126235753843](./assets/image-20221126235753843.png)

#### 1.绝对装入

绝对装入，==编译==时知道起始地址后直接修改逻辑地址，但是灵活性低，只适合单道程序环境，因为同一时刻只会有一个程序在内存里

![image-20221127000931431](./assets/image-20221127000931431.png)

#### 2.静态重定位

和绝对定位很像，==装入==使所有和地址有关的参数都修改

> 图中第一行的意思：编译链接后的装入模块的起始地址都以0开始，就是保持逻辑地址不变，在装入时再修改

![image-20221127001204055](./assets/image-20221127001204055.png)

#### 3.动态重定位

地址上的转变要留到运行时进行

![image-20221127001643621](./assets/image-20221127001643621.png)

该方法需要物理装置上的支持：**重定位寄存器**；存放装入模块的起始地址

![image-20221127001900701](./assets/image-20221127001900701.png)

该方式还有的优点：

- 可以将程序分配到不连续的存储区中；
- 在程序运行前只需要装入它的部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；
- 便于程序段的共享，可以向用户提供一个比存储空间大的多的地址空间

> 这些优点在后续的分段分页方式上体现

### 链接的三种方式

#### 1.静态链接

![image-20221127002208392](./assets/image-20221127002208392.png)

#### 2.装入时动态链接

边装入边链接

![image-20221127002234553](./assets/image-20221127002234553.png)

#### 3.运行时动态链接

后来学的分页分段存储用的都是这个

![image-20221127002336950](./assets/image-20221127002336950.png)

## 三、总结

![image-20221127002444894](./assets/image-20221127002444894.png)

# 4.1.2内存管理的概念

```mermaid
graph LR
Title(内存管理的概念)-->A(内存空间的分配和回收)
Title-->B(内存空间的扩充)
Title-->C(地址转换)
Title-->D(存储保护)
```

### 一、内存空间的分配和回收

- 如何分配内存
- 如果有多个位置可以放进程，放哪个
- 进程运行完，如何回收内存

![image-20221127140234427](./assets/image-20221127140234427.png)

### 二、内存空间的拓展

![image-20221127140404760](./assets/image-20221127140404760.png)

### 三、地址转换

> 操作系统需要提供地址转换功能，负责程序的逻辑地址和物理地址的转换

为了让编程方便，程序员写程序只需要关注指令、数据的逻辑地址。而==逻辑地址到物理地址的转换==(这个过程称为地址重定位)应该由操作系统负责，这样就方便了程序员写程序时不需要关注物理内存的实际情况。

之前介绍的三种装入方式

![image-20221127140724769](./assets/image-20221127140724769.png)

### 四、内存保护

> 操作系统需要提供内存保护功能，保证各进程在各自存储空间内运行，互不干扰

进程一不能访问操作系统进程和其他普通进程，不然系统不安全，有两种方式

- 方式一：设置两个寄存器，两个都放物理地址

![image-20221127141050723](./assets/image-20221127141050723.png)

- 方式二：还是两个寄存器，但是一个存放的是物理起始地址，一个是最大的逻辑地址

如图所示，要访问逻辑地址80的地址空间，没有超过179，所以可以正常访问

![image-20221127141225057](./assets/image-20221127141225057.png)

### 五、总结

这章就是对内存管理有个大致了解，每个部分后面都会仔细再学

![image-20221127141626483](./assets/image-20221127141626483.png)

# 4.1.3 覆盖与交换

```mermaid
graph LR
Title(内存空间的扩充)-->覆盖技术
Title-->交换技术
Title-->虚拟存储技术
```

## 一、覆盖技术

> 覆盖发生在同一个程序或者进程中

![image-20221127162411460](./assets/image-20221127162411460.png)

例子：

A程序会依次调用B、C程序，B、C同理调用DEF，所以B和C同用一个覆盖区且覆盖区大小取较大值。

但是这种操作系统不能自己知道到底需要多少覆盖区，需要程序员自己声明。

![image-20221127162614643](./assets/image-20221127162614643.png)

## 二、交换技术

> 交换发生在不同进程之间的

注意，进程的PCB需要常驻内存，我们需要知道进程换出到了什么位置

![image-20221127162954468](./assets/image-20221127162954468.png)

知识回忆：挂起状态

![image-20221127163052489](./assets/image-20221127163052489.png)

思考问题

1. 应该在外存(磁盘)什么位置保存被换出的进程？
2. 什么时候应该交换？
3. 应该换出哪些进程？

![image-20221127163501420](./assets/image-20221127163501420.png)

  

## 三、总结

![image-20221127163629167](./assets/image-20221127163629167.png)

# 4.1.4 内存连续分配管理方式

```mermaid
graph LR
Title(内存空间的分配和回收)-->A(连续分配管理方式)
Title-->B(非连续分配管理方式)
A-->单一分配方式
A-->固定分区分配
A-->动态分区分配
```

> 连续分配：指为用户进程分配的必须是一个连续的内存空间。
>
> 这章问题在与，如何给进程分配内存，该分配到内存的什么位置

## 一、单一连续分配

注意，用户区内只有一个用户程序！

![image-20221127170640443](./assets/image-20221127170640443.png)

## 二、固定分区分配

![image-20221127170833660](./assets/image-20221127170833660.png)

操作系统如何知道内存的分配情况呢？需要一个分区说明表

![image-20221127170953135](./assets/image-20221127170953135.png)

## 三、动态分区分配

引出问题：

![image-20221127171152628](./assets/image-20221127171152628.png)

如果进程2运行完被撤出，空出一个14MB的空间，有一个新的4MB的进程4进入，该放在哪个分区进行分配呢？

![image-20221127171453460](./assets/image-20221127171453460.png)

如果进程3被撤离，空出来18MB的空间，这空闲分区如何进行操作？需不需要合并？

![image-20221127171529987](./assets/image-20221127171529987.png)

### 1.什么数据结构来记录内存的使用情况?

![image-20221127171745306](./assets/image-20221127171745306.png)

### 2.如何进行分区分配

动态分区分配算法在下一章4.1.5

![image-20221127171946658](./assets/image-20221127171946658.png)

### 3.如何进行分区回收

> 其实很简单，有新的空闲分区了，就看一下有没有相邻的，相邻的就合并为一个，没有就新增一个表项

第一种：回合区的后面有个相邻的空闲分区：

**两个相邻的空闲分区合并为一个**空闲分区表的分区大小和起始地址要进行更新

![OS1](./assets/OS1.gif)

第二种：回收区的前面有一个相邻的空闲分区

和第一种类似，**两个相邻的空闲分区合并为一个**

![OS2](./assets/OS2.gif)

第三种：回收区的前、后各有一个相邻的空闲分区

和一、二种类似，**三个相邻的空闲分区合并为一个**

![OS3](./assets/OS3.gif)

第四种：回收区的前、后没有相邻的空闲分区

新增一个表项。注意：各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区算法来确定

![OS4](./assets/OS4.gif)

### 4.碎片问题

![image-20221127180406998](./assets/image-20221127180406998.png)

紧凑技术就是把内存挪位，凑一个大空间出来

![OS5](./assets/OS5.gif)

## 四、总结

![image-20221127180621847](./assets/image-20221127180621847.png)

# 4.1.5 动态分区分配算法

在动态分区分配方式中，很多个空闲分区都满足需求时，该选择哪个分区进行分配呢？

```mermaid
graph LR
Title(动态分区分配算法)-->A(首次适应算法First Fit)
Title-->B(最佳适应算法Best Fit)
Title-->C(最坏适应算法Worst Fit)
Title-->D(邻近适应算法Next Fit)
```

## 1.首次始应算法

![image-20221127183243419](./assets/image-20221127183243419.png)

## 2.最佳适应算法

找到第一个能满足新进程大小且分区大小是最小的情况下的空闲分区

![image-20221127183701815](./assets/image-20221127183701815.png)

## 3.最坏适应算法

![image-20221127183827416](./assets/image-20221127183827416.png)

## 4.邻近适应算法

对首次适应算法的改进

![image-20221127184114457](./assets/image-20221127184114457.png)

## 总结

![image-20221127184202061](./assets/image-20221127184202061.png)

# 4.1.6 基本分页存储管理概念

