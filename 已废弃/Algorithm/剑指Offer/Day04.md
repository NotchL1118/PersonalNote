# 数组中重复的数字

> 难度：简单

## 题目

在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。

**示例 1：**

```
输入：
[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3 
```

## 思路

方法一、哈希表/Set

利用数据结构特点，很容易想到使用哈希表(Map)记录数字各个数字，当查找到重复数字就直接返回

方法二、原地交换

要充分利用题目所给信息`在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内`，试想，如果这n个的数不重复且都在`0~n-1`范围内，那么数组的**索引值和值应该是一对一的关系**，即[0,1,2,3,...,n-1]。题目说了会有重复的数，那么**索引值和值就会是一对多的关系**，因此可以通过遍历数组并通过交换操作，使得数组的索引和值一一对应(即`nums[i] == i`)，因此就能通过索引映射对应值，找到与字典等价的作用。

<img src="https://pic.leetcode-cn.com/1618146573-bOieFQ-Picture0.png" width="50%"/>

遍历中，第一次遇到数字`x`时，将其交换至索引`x`处，当第二次遇到数字`x`时，一定会有`nums[x] = x`的情况，这时候就可以得到一组重复的数字。

## 代码

方法一、哈希表

```typescript
function findRepeatNumber(nums: number[]): number {
    const map:Map<number,number>=new Map();
    for(let i of nums){
        if(map.has(i)) 
            return i;
        else
            map.set(i,1);
    }
};
```

方法二、原地交换

1. 遍历数组`nums` ，设索引初始值为`i=0`
   1. 若`nums[i]=i`说明此数字已在对应索引位置，无需交换，因此跳过；
   2. 若`nums[nums[i]] = nums[i]`:代表索引`nums[i]`处和索引`i`处的元素值都为`nums[i]`，即找到了一组重复值，返回此值。
   3. 上述两个条件都不满足，那么交换索引为`i`和`nums[i]`的元素值，将此数字交换到对应索引位置。
2. 若遍历完毕尚未返回，则返回-1。

```typescript
    let i = 0;
    while(i < nums.length) {
        if(nums[i] == i) {
            i++
            continue
        }
        if(nums[nums[i]] == nums[i]) {
            return nums[i]
        }
        let tmp = nums[nums[i]]
        nums[nums[i]] = nums[i]
        nums[i] = tmp
    }
	return -1
```

注意，当`nums[i] != i`时，索引`i`是不会继续前进的，会一直换下去，但这个过程不会是无穷次的，最多搜完所有其他值`n-1`次。(这里卡了一下，如果是a=[2,1,2,4,3],索引值是[0,1,2,3,4]对吧，如果a[0]和a[2]交换不是会无穷的交换下去吗，其实这种根本进行不到交换命令，因为这时候a[2]已经可以看成归位了，索引和元素值是一一对应的，直接就可以找到重复值就是2)所以`i`的左边的数组元素**索引和元素值是一一对应的**

## 复杂度

方法一、哈希表

**时间复杂度O(n)**:遍历数组使用O(n),哈希表插入和查找元素皆为O(1)

**空间复杂度O(n)**:哈希表占用O(n)大小的额外空间

方法、原地交换

**时间复杂度 O(N):**遍历数组使用 O(n)，每轮遍历的判断和交换操作使用O(1) 。

**空间复杂度 O(1):**使用常数复杂度的额外空间。

# 在排序数组中查找数字I

> 难度：简单

统计一个数字在排序数组中出现的次数。

**示例 1:**

```
输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
```

**示例 2:**

```
输入: nums = [5,7,7,8,8,10], target = 6
输出: 0
```

## 思路

排序数组了，明示用二分了，用二分分别找第一次出现的位置和最后一次出现的位置，蓝桥杯也做过原题

y总的模板，确实好用好吧

<img src="https://cdn.acwing.com/media/article/image/2022/03/26/78092_86646857ac-erfen.png" width=50%/>

## 代码

```typescript
    function search(nums: number[], target: number): number {
        let l = 0, r = nums.length - 1 
        while(l < r) {
            let mid = Math.floor((l + r) / 2)
            if(nums[mid] >= target) r = mid 
            else l = mid + 1 
        }
        if(nums[l] !== target) return 0
        let tmp = l
        r = nums.length - 1
        while(l < r) {
            let mid = Math.ceil((l + r) / 2)
            if(nums[mid] <= target) l = mid
            else r = mid -1
        }
        return (l - tmp + 1)
    };
```

## 复杂度

- **时间复杂度O(logN)：**二分法为对数级别复杂度。
- **空间复杂度O(1)：**几个变量使用常数大小的额外空间。

# 0~n-1中缺失的数字

> 难度：简单

一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

**示例 1:**

```
输入: [0,1,3]
输出: 2
```

**示例 2:**

```
输入: [0,1,2,3,4,5,6,7,9]
输出: 8
```