# IOC/DI

> [小满zs](https://blog.csdn.net/qq1195566313/article/details/126151370?ops_request_misc=&request_id=2345c0a0b00a4874be6efb29114c94ce&biz_id=&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~koosearch~default-28-126151370-null-null.268^v1^control&utm_term=nestjs&spm=1018.2226.3001.4450)
>
> [全栈码叔](https://www.bilibili.com/video/BV1KW4y1L7te/?spm_id_from=333.788&vd_source=7dcb6c648b7faefd7170d0fc0494d4ad)

## 概念

- IOC

> 更注重于why

Inversion of Control字面意思是控制反转，具体定义是高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。

- DI

> 更注重于how，是实现IOC的一种手段

依赖注入（Dependency Injection）其实和IoC是同根生，这两个原本就是一个东西，只不过由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”。 类A依赖类B的常规表现是在A中使用B的实例。

依赖：名词，指被依赖的对象（面向对象）

注入：动词，指被依赖对象，在使用者对象中的生成方式，**是被注入的，而不是由使用者自己去生成的**

构造函数里面传递被依赖对象实例，是注入的方式之一，还有其他注入方式。

## 为什么使用依赖注入

后端系统中，会有很多对象：

- Controller 对象：接收 http 请求，调用 Service，返回响应
- Service 对象：实现业务逻辑
- Repository 对象：实现对数据库的增删改查

此外，还有数据库链接对象 DataSource，配置对象 Config 等等。这些对象有着错综复杂的关系：

**Controller 依赖了 Service 实现业务逻辑，Service 依赖了 Repository 来做增删改查，Repository 依赖 DataSource 来建立连接，DataSource 又需要从 Config 对象拿到用户名密码等信息。**

这就导致了创建这些对象是很复杂的，你要理清它们之间的依赖关系，哪个先创建哪个后创建。

每次手动组装这些对象非常的麻烦，我们可以在类上声明需要哪些依赖，然后让工具来分析声明的依赖关系，再根据先后顺序自动化创建对象再组装，**也就是通过一套机制来自动化这套过程，减少手动操作量。**

## 简单案例

案例未使用控制反转和依赖注入之前的代码，normal模式的代码↓

```ts
class A {
    name: string
    constructor(name: string) {
        this.name = name
    }
}

class B {
    age:number
    entity:A
    constructor (age:number,name:string) {
        this.age = age;
        this.entity = new A(name)
    }
}
const c = new B(18)
c.entity.name
```


我们可以看到，B 中代码的实现是需要依赖 A 的，两者的代码耦合度非常高。当两者之间的业务逻辑复杂程度增加的情况下，维护成本与代码可读性都会随着增加，并且很难再多引入额外的模块进行功能拓展,就比如说，我需要在A类中增加一个参数，那么我还需要同样的在B类的construor中增加对应的参数，因为是由B类来进行控制的，控制反转就是将这个控制权交出来，我们直接使用一个实例化好了的A类对象来进行组装，而不是在B类内部自己控制，每次A类有需要增加内容都不需要到B类里面修改。

为了解决这个问题可以使用IOC容器

```ts
class A {
    name: string
    constructor(name: string) {
        this.name = name
    }
}
class C {
    name: string
    constructor(name: string) {
        this.name = name
    }
}
//中间件用于解耦
class Container {
    modeuls: any
    constructor() {
        this.modeuls = {}
    }
    provide(key: string, modeuls: any) {
        this.modeuls[key] = modeuls
    }
    get(key) {
        return this.modeuls[key]
    }
}
const mo = new Container()
mo.provide('a', new A('小满1'))
mo.provide('c', new C('小满2'))

class B {
    a: any
    c: any
    constructor(container: Container) {
        this.a = container.get('a')
        this.c = container.get('c')
    }
}

new B(mo)
```

在引入IOC容器container之后，B和A的代码逻辑已经解耦了，可以单独拓展其他功能，也可以方便地加入其他模块，比如C，在面对复杂的后端业务逻辑时，引入IOC可以降低组件之间的耦合度，实现系统各层级之前的解耦，减少维护和理解成本。

比如A类需要增加新的参数，那我们也只需要`mo.provide('a', new A('小满1'))`的时候添加新的参数就好了，不需要再到B中再增加对应参数，增加可维护性。

## 元数据反射

我们都知道 ts 中的类型信息是在运行时是不存在的，那运行时是如何根据参数的类型注入对应实例的呢？

答案就是：**元数据反射**

先说反射，**反射就是在运行时动态获取一个对象的一切信息：方法/属性等等**，特点在于**动态类型反推导**。不管是在 ts 中还是在其他类型语言中，反射的本质在于元数据。在 TypeScript 中，反射的原理是通过编译阶段对对象注入元数据信息，在运行阶段读取注入的元数据，从而得到对象信息。

元数据反射（Reflect Metadata） 是 ES7 的一个提案，它主要用来在声明的时候添加和读取元数据。TypeScript 在 1.5+ 的版本已经支持它。要在 ts 中启用元数据反射相关功能需要：

- `npm i reflect-metadata --save`。
- 在 `tsconfig.json` 里配置 `emitDecoratorMetadata` 选项为`true`。

- **定义元数据**

```
Reflect.defineMetadata(metadataKey, data, target)
```

可以定义一个类的元数据；

- **获取元数据**

```
Reflect.getMetadata(metadataKey, target)
Reflect.getMetadata(metadataKey, instance, methodName)
```

可以获取类或者方法上定义的元数据。

- **内置元数据**

TypeScript 结合自身语言的特点，为使用了装饰器的代码声明注入了3组元数据：

1. `design:type`：成员类型
2. `design:paramtypes`：成员所有参数类型
3. `design:returntype`：成员返回类型

### 例子

在这个例子里，我们定义了一个名为 Module 的装饰器，这个装饰器的主要作用就是往装饰的类上添加一些元数据。然后用装饰器装饰 C 类。我们就可以获取到这个参数中的信息了;

```ts
import 'reflect-metadata';
class A {
  sayHi() {
    console.log('hi');
  }
}
class B {
  sayHello() {
    console.log('hello');
  }
}

function Module(metadata) {
  const propsKeys = Object.keys(metadata);
  return (target) => {
    for (const property in metadata) {
      if (metadata.hasOwnProperty(property)) {
        Reflect.defineMetadata(property, metadata[property], target);
      }
    }
  };
}
@Module({
  controllers: [B],
  providers: [A],
})
class C {}

const providers = Reflect.getMetadata('providers', C);
const controllers = Reflect.getMetadata('controllers', C);
console.log(providers, controllers); // [ [class A] ] [ [class B] ]

(new (providers[0])).sayHi(); // 'hi'
```

