# 描述UI

## [你的第一个组件](https://zh-hans.react.dev/learn/your-first-component)

- **React 组件是一段可以 使用标签进行扩展 的 JavaScript 函数**

- React 组件是常规的 JavaScript 函数，但 **组件的名称必须以大写字母开头**，否则它们将无法运行！(只有这样React知道我们想要使用名为 `Xxx` 的组件)

- `<img/>` 写得像 HTML，但实际上是 JavaScript！这种语法被称为 JSX，它允许你在 JavaScript 中嵌入标签。(和Vue一样，看着template中和HTML一样，其实不是，只是类似方便程序员编程)

- 组件可以渲染其他组件，但是**请不要嵌套他们的定义**↓，这样会非常慢，且有bug产生。因此，应该在顶层定义每个组件

  ```jsx
  export default function Gallery() {
    // 🔴 永远不要在组件中定义组件
    function Profile() {
      // ...
    }
    // ...
  }
  ```

- React 是常规的 JavaScript 函数，除了：
  1. 它们的名字总是以大写字母开头。
  2. 它们返回 JSX 标签。
  
  > 为什么不要嵌套定义，因为每次Gallery组件渲染时，都会重新创建一个Profile函数组件，对于React来说，每次渲染的就是不同的组件，会导致组件内部的state重置，详细见[《相同位置的不同组件会使state重置》](https://zh-hans.react.dev/learn/preserving-and-resetting-state#different-components-at-the-same-position-reset-state)

## [使用JSX书写标签语言](https://zh-hans.react.dev/learn/writing-markup-with-jsx)

- [为什么多个 JSX 标签需要被一个父元素包裹？](https://zh-hans.react.dev/learn/writing-markup-with-jsx#why-do-multiple-jsx-tags-need-to-be-wrapped)

JSX 虽然看起来很像 HTML，但在底层其实被转化为了 JavaScript 对象，你不能在一个函数中返回多个对象，除非用一个数组把他们包装起来。这就是为什么多个 JSX 标签必须要用一个父元素或者 Fragment 来包裹。

- 每个 React 组件都是一个 JavaScript 函数，它会返回一些标签，React 会将这些标签渲染到浏览器上。React 组件使用一种被称为 JSX 的语法扩展来描述这些标签。**JSX 看起来和 HTML 很像，但它的语法更加严格并且可以动态展示信息**。

- [JSX and React 是相互独立的](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#whats-a-jsx-transform) 东西。但它们经常一起使用，但你 **可以** 单独使用它们中的任意一个，JSX 是一种语法扩展，而 React 则是一个 JavaScript 的库。

## [将Props传递给组件](https://zh-hans.react.dev/learn/passing-props-to-a-component)

- props 是 [不可变的](https://en.wikipedia.org/wiki/Immutable_object)（一个计算机科学术语，意思是“不可改变”）。当一个组件需要改变它的 props（例如，响应用户交互或新数据）时，它不得不“请求”它的父组件传递 **不同的 props** —— 一个新对象！它的旧 props 将被丢弃，最终 JavaScript 引擎将回收它们占用的内存。

- Props 是只读的时间快照：每次渲染都会收到新版本的 props

## [保持组件纯粹](https://zh-hans.react.dev/learn/keeping-components-pure)

- 在计算机科学中（尤其是函数式编程的世界中），[纯函数](https://wikipedia.org/wiki/Pure_function) 通常具有如下特征：
  - **只负责自己的任务**。它不会更改在该函数调用前就已存在的对象或变量。
  - **输入相同，则输出相同**。给定相同的输入，纯函数应总是返回相同的结果。
- React 便围绕着这个概念进行设计。**React 假设你编写的所有组件都是纯函数**。也就是说，对于相同的输入，你所编写的 React 组件必须总是返回相同的 JSX。

- 函数式编程在很大程度上依赖于纯函数，但 **某些事物** 在特定情况下不得不发生改变。这是编程的要义！这些变动包括更新屏幕、启动动画、更改数据等，它们被称为 **副作用**。它们是 **“额外”** 发生的事情，与渲染过程无关。

  在 React 中，**副作用通常属于 [事件处理程序](https://zh-hans.react.dev/learn/responding-to-events)**。事件处理程序是 React 在你执行某些操作（如单击按钮）时运行的函数。即使事件处理程序是在你的组件 **内部** 定义的，它们也不会在渲染期间运行！ **因此事件处理程序无需是纯函数**。

  如果你用尽一切办法，仍无法为副作用找到合适的事件处理程序，你还可以调用组件中的 [`useEffect`](https://zh-hans.react.dev/reference/react/useEffect) 方法将其附加到返回的 JSX 中。这会告诉 React 在渲染结束后执行它。**然而，这种方法应该是你最后的手段**。

# [添加交互](https://zh-hans.react.dev/learn/adding-interactivity)

## [组件的记忆](https://zh-hans.react.dev/learn/adding-interactivity#state-a-components-memory)

- 组件通常需要根据交互改变屏幕上的内容。在表单中键入更新输入栏，在轮播图上点击“下一个”改变显示的图片，点击“购买”将产品放入购物车。组件需要“记住”一些东西：当前的输入值、当前的图片、购物车。**在 React 中，这种特定于组件的记忆被称为状态**。

- 你可以用 [`useState`](https://zh-hans.react.dev/reference/react/useState) Hook 为组件添加状态。***Hook* 是能让你的组件使用 React 功能的特殊函数**（状态是这些功能之一）。

## [响应事件]()

- 确保为事件处理程序使用适当的 HTML 标签。例如，要处理点击事件，请使用 [`<button onClick={handleClick}>`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button) 而不是 `<div onClick={handleClick}>`。使用真正的浏览器 `<button>` 启用内置的浏览器行为，如键盘导航。如果你不喜欢按钮的默认浏览器样式，并且想让它看起来更像一个链接或不同的 UI 元素，你可以使用 CSS 来实现。

## [state：组件的记忆](https://zh-hans.react.dev/learn/state-a-components-memory)

- Hook 是特殊的函数，只在 React [渲染](https://zh-hans.react.dev/learn/render-and-commit#step-1-trigger-a-render)时有效
- Hook 是函数，但将它们视为关于组件需求的无条件声明会很有帮助。在组件顶部 “use” React 特性，类似于在文件顶部“导入”模块。

- 与 props 不同，**state 完全私有于声明它的组件**。父组件无法更改它。

- Hook 是以 `use` 开头的特殊函数。它们能让你 “hook”（“勾到”）到像 state 这样的 React 特性中。

- **Don’t call Hooks inside loops, conditions, or nested functions**
- **Only Call Hooks from React Functions**

## [state如同一张快照](https://zh-hans.react.dev/learn/state-as-a-snapshot)

> 其实本章大致意思就是在一次渲染的期间，state值是不会变的(在一次渲染里，可以把state当作是常量看待)，setter函数只会在下一次渲染前把值设置为最新值(并且同一个state的后一次的setter函数运行结果会覆盖前一次的setter函数的运行结果)，就相当于Vue里面的，你如果想使用最新的值，得在更新后才能使用。

- **一个 state 变量的值永远不会在一次渲染的内部发生变化，** 即使其事件处理函数的代码是异步的。

- **React 会使 state 的值始终“固定”在一次渲染的各个事件处理函数内部**。
- 变量和事件处理函数不会在重渲染中“存活”。每个渲染都有自己的事件处理函数。(渲染是名词)
- 每个渲染（以及其中的函数）始终“看到”的是 React 提供给**这次**渲染的 **state 快照**(渲染是名词)

## [更新state中的对象](https://zh-hans.react.dev/learn/updating-objects-in-state)

- **将 React 中所有的 state 都视为不可直接修改的。**

## [更新state中的数组](https://zh-hans.react.dev/learn/updating-arrays-in-state)

- **当你更新一个嵌套的 state 时，你需要从想要更新的地方创建拷贝值，一直这样，直到顶层。**

# [状态管理]()

## [用state响应输入](https://zh-hans.react.dev/learn/reacting-to-input-with-state)

- **防止出现在内存中的 state 不代表任何你希望用户看到的有效 UI 的情况**

## [构建state的原则](https://zh-hans.react.dev/learn/choosing-the-state-structure)

1. **合并关联的 state**。如果你总是同时更新两个或更多的 state 变量，请考虑将它们合并为一个单独的 state 变量。
2. **避免互相矛盾的 state**。当 state 结构中存在多个相互矛盾或“不一致”的 state 时，你就可能为此会留下隐患。应尽量避免这种情况。
3. **避免冗余的 state**。如果你能在渲染期间从组件的 props 或其现有的 state 变量中计算出一些信息，则不应将这些信息放入该组件的 state 中。
4. **避免重复的 state**。当同一数据在多个 state 变量之间或在多个嵌套对象中重复时，这会很难保持它们同步。应尽可能减少重复。
5. **避免深度嵌套的 state**。深度分层的 state 更新起来不是很方便。如果可能的话，最好以扁平化方式构建 state。

6. 不要直接镜像props
   以下代码是体现 state 冗余的一个常见例子：

````jsx
function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);
````
这里，一个 color state 变量被初始化为 messageColor 的 prop 值。这段代码的问题在于，如果父组件稍后传递不同的 messageColor 值（例如，将其从 'blue' 更改为 'red'），则 color state 变量将不会更新！ state 仅在第一次渲染期间初始化。
这就是为什么在 state 变量中，“镜像”一些 prop 属性会导致混淆的原因。相反，你要在代码中直接使用 messageColor 属性。如果你想给它起一个更短的名称，请使用常量：
```jsx
function Message({ messageColor }) {
  const color = messageColor;
```

**只有当你想要忽略特定 props 属性的所有更新时，将 props “镜像”到 state 才有意义。**按照惯例，prop 名称以 `initial` 或 `default` 开头，以阐明该 prop 的新值将被忽略：

```jsx
function Message({ initialColor }) {
  // 这个 `color` state 变量用于保存 `initialColor` 的 **初始值**。
  // 对于 `initialColor` 属性的进一步更改将被忽略。
  const [color, setColor] = useState(initialColor);
```

## [对state进行保留和重置](https://zh-hans.react.dev/learn/preserving-and-resetting-state)

- **对 React 来说重要的是组件在 UI 树中的位置,而不是在 JSX 中的位置！** 

- **永远要将组件定义在最上层并且不要把它们的定义嵌套起来。**(每次重新创建组件函数，对于React来说就是不同的组件)
- 请记住 key 不是全局唯一的。它们只能指定 **父组件内部** 的顺序。

# 自己的想法

- 事件处理函数中设置state即setState -> 添加**设置函数**（更新函数 或者 设置一个新值）到队列里 -> 等事件处理函数完 -> 重新渲染，执行组件函数，这时候useState会扫描队列，更新state，然后重新渲染最新的界面
- (目前理解的)执行组件函数并不完全等于渲染，只是返回一个最新的jsx，由React计算得出最少的必要操作，然后转化为真实DOM才叫渲染
