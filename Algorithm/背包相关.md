# 01背包获取所选方案

```js
#include <iostream>
using namespace std;
const int N = 1e3 + 10;
int n,m;
int c[N],v[N];
int dp[N][N];
int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i ++ ) cin >> c[i] >> v[i];
    for(int i = 1; i <= n; i ++ ) {
        for(int j = 0; j <= m; j ++ ) {
            dp[i][j] = dp[i-1][j];
            if(j >= c[i]) dp[i][j] = max(dp[i][j],dp[i-1][j-c[i]] + v[i]);
        }
    }
    
    int t = m;
    for(int i = n; i >= 1; i--) {
        if(dp[i][t] == dp[i-1][t]) {
            continue;
        } else if (dp[i][t] == dp[i-1][t-c[i]] + v[i]) {
            cout << "选了价值为" <<  v[i] << "的" << i << endl;
            t -= c[i];
        }
    }
    cout << dp[n][m];
    return 0;
}
```

核心是

```js
    int t = m;
    for(int i = n; i >= 1; i--) {
        if(dp[i][t] == dp[i-1][t]) {
            continue;
        } else if (dp[i][t] == dp[i-1][t-c[i]] + v[i]) {
            cout << "选了价值为" <<  v[i] << "的" << i << endl;
            t -= c[i];
        }
    }
```

从后往前遍历，如果`dp[i][t] == dp[i-1][t]`就说明，第i个物品没有选，直接到上一层，如果是另一个，那就说明第i个物品选了。

# 完全背包问题

```js
#include <iostream>
using namespace std;
const int N = 1e3 +10;
int n,m;
int c[N],w[N];
int dp[N][N];
int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++ ) cin >> c[i] >> w[i];
    for(int i = 1; i <= n; i++ ) {
        for(int j = 0; j <= m; j ++ ) {
            dp[i][j] = dp[i-1][j];
            if(j >= c[i]) dp[i][j] = max(dp[i][j],dp[i][j-c[i]] + w[i]);
        }
    }
    int t = m;
    for(int i = n; i >= 1; i--){
        if(dp[i][t] == dp[i-1][t]) continue;
        else if (dp[i][t] == dp[i][t-c[i]] + w[i]) {
            cout << i << " " << w[i] << endl;
            t -= c[i];
            i++;
        }
    }
    cout << dp[n][m];
    return 0;
}
```

核心代码类似，不过这一次，如果`dp[i][t] == dp[i][t-c[i]] + w[i]`，就说明第i个物品选了，但不知道选了几次，所以需要i++来避免最后到上一层去。

```js
    int t = m;
    for(int i = n; i >= 1; i--){
        if(dp[i][t] == dp[i-1][t]) continue;
        else if (dp[i][t] == dp[i][t-c[i]] + w[i]) {
            cout << i << " " << w[i] << endl;
            t -= c[i];
            i++;
        }
    }
```

## 组合OR排列

先遍历物品再遍历背包，求的是组合数

先遍历背包再遍历物品，求的是排列数
