# 事件循环

> [这个视频讲的特别好](https://www.bilibili.com/video/BV1oV411k7XY/?spm_id_from=333.788.recommend_more_video.-1)
>
> [这个文章讲的特别好](https://juejin.cn/post/6844903512845860872)

## 前提

1. JavaScript在设计之初便是单线程语言，因为该语言是为了处理浏览器中页面交互、操作DOM和CSS而设计出来的，如果设计成多线程，线程A删除了DOM，线程B添加了DOM，浏览器就不知道如何处理，为了避免这种复杂性，JavaScript自诞生起就是单线程，**单线程也是这门语言的核心特征**。一切**JS的多线程都是单线程模拟出来的**。

> HTML5中提出了Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程是完全受主线程控制的，而且不得操作DOM，所以这个标准并没有改变JavaScript是单线程的本质。

2. 此外，我们要知道V8引擎和浏览器之间的关系，可以确定一下几点，[来自这里]([浏览器下的事件循环 - 掘金 (juejin.cn)](https://juejin.cn/post/6859542374042763278))

   - 浏览器提供了JS代码运行的额外环境，比如window对象，**事件循环模型**

   - V8引擎只负责执行JS代码的执行，调用栈有什么代码就执行什么，至于代码什么时候、什么顺序入栈则由浏览器来控制

> V8引擎只是个打手，浏览器来控制他打人的顺序、打什么人

## 事件循环

### 出现背景

但是设计成单线程语言，就不可避免的出现了阻塞的问题。同一时刻只能做一件事，如果一个任务过长，那么后面的任务都得等待。那么用户体验非常糟糕：如果我们只想看新闻，新闻里的图片加载很慢，网页就得一直卡着等图片加载出来才能完全显现。此外还有更加糟糕的现象，或者比如下面这段代码

<img src="https://pic.lsyfighting.cn/img/image-20230607152412243.png" alt="image-20230607152412243" style="zoom: 50%;" />

比如每一个ajax请求都会持续1~5s，那么在同步执行代码情况下，当浏览器在请求的时候，**我们是无法点击页面的其他操作的**，因为浏览器渲染任务也是浏览器需要不停的添加到调用栈中，但是因为当前调用栈一直卡在网络请求，所以浏览器没法执行渲染事件(具体见下文)，这样体验就非常非常糟糕。

<img src="https://pic.lsyfighting.cn/img/image-20230607152509503.png" alt="image-20230607152509503" style="zoom: 50%;" />

### 事件循环概述

程序员将任务分为两类：

- 同步任务
- 异步任务

<img src="https://pic.lsyfighting.cn/img/15fdd88994142347tplv-t2oaga2asx-zoom-in-crop-mark1512000.webp" alt="img" style="zoom: 50%;" />

- 同步任务按照代码顺序和调用顺序，直接进入调用栈中执行，执行结束就移出调用栈。
- 异步任务进入Event Table中，当指定的事情发生(比如定时器时间到了、服务器响应请求了)，Event Table就会将回调函数移入Event Queue任务队列中去。
- 当调用栈中的代码都执行完了，就会去Event Queue任务队列中读取回调函数，放入到调用栈中执行。
- 这个过程不断的重复，就是我们常说的事件循环Event Loop

JS引擎存在monitoring process进程(JS语言是单线程的，引擎底层不是)，会不断的检查主线程是否为空，一旦为空，就会去任务队列中检查是否有回调函数。

例子如下代码：

```js
let data = [];
$.ajax({
    url:www.javascript.com,
    data:data,
    success:() => {
        console.log('发送成功!');
    }
})
console.log('代码执行结束');
```

- ajax先进入Event Table
- 打印‘代码执行结束’
- ajax事件完成，回调函数success进入Event Queue任务队列
- 主线程从任务队列中读取回调函数success并执行

#### 任务入队知识点

回调函数入队，就利用了浏览器的其他进程，**虽然是JavaScript语言是单线程语言，但是浏览器软件不是**，浏览器有多个线程可以对不同的事件进行处理，当对应回调函数满足执行条件之后，对应的进程就会将其加入到对应的任务队列。

- js引擎线程：用于解释js代码，用户输入，网络请求等
- GUI渲染线程：绘制用户界面，与JS主线程互斥(因为JS可以操控DOM，进而影响GUI的渲染结果)
- http异步网络请求线程：处理用户的get、post等网络请求，等返回结果后将回调函数推入到任务队列
- 定时触发器线程：`setInterval`、`setTimeout`等待时间结束后，会把执行函数推入任务中
- 浏览器事件处理线程：`click`、`mouse`等UI交互事件发生后，将要执行的回调函数放入到任务队列中。

### 宏任务、微任务

我们对任务还有更细的划分

- macro-task宏任务：包括整体代码script、setTimeout、setInterval
- micro-task微任务：Promise、process.nextTick

> 为什么这么划分没找到具体的原因，可能是让JS可以在渲染阶段前后拥有完成某些功能的能力，就像Vue的生命周期钩子一样

任务队列也有了细分，分别对应宏任务、微任务

- 宏任务队列
- 微任务队列

#### 宏微分类

| 宏任务                | 浏览器 | node |
| :-------------------- | ------ | ---- |
| 整体代码script        | ✅      | ✅    |
| UI交互事件            | ✅      | ❌    |
| I/O事件               | ✅      | ✅    |
| setTimeout            | ✅      | ✅    |
| setInterval           | ✅      | ✅    |
| setImmediate          | ❌      | ✅    |
| requestAnimationFrame | ✅      | ❌    |

| 微任务                      | 浏览器 | node |
| --------------------------- | ------ | ---- |
| `process.nextTick`          | ❌      | ✅    |
| Mutation Observer           | ✅      | ❌    |
| Promise. Then catch finally | ✅      | ✅    |

### 事件循环总体顺序

<img src="https://pic.lsyfighting.cn/img/15fdcea13361a1ectplv-t2oaga2asx-zoom-in-crop-mark1512000.webp" alt="img" style="zoom:50%;" />

1. 从宏任务队列中，按照入队顺序，找到第一个执行的宏任务，调入调用栈，开始执行；
2. 执行完该宏任务下的所有同步任务后，即调用栈清空后，该宏任务被推出宏任务队列，然后微任务队列开始按照入队顺序，依次执行其中的微任务，**直至微任务队列清空为止**；
3. 当微任务队列清空后，**一次事件循环结束。**
4. 浏览器就检查是否需要更新页面，如果需要就会渲染页面
5. 接着从宏任务队列中，找到下一个执行的宏任务，开始第二次事件循环，直至宏任务队列清空为止。

**注意点：**

- 当我们首次执行时，解释器会将**整体代码script**放入宏任务队列，因此事件循环是从第一个宏任务开始的；
- **如果在执行微任务的过程中，产生新的微任务到微任务队列中，需要一起清空；微任务队列没清空之前，不会执行下一个宏任务的。**
- **执行完一次宏任务，就会去扫描微任务队列，不是清空了宏任务再执行微任务。**

### 页面渲染

当一次事件循环结束后，即一个宏任务执行完并且微任务队列被清空后，浏览器就会进行一次更新渲染。

通常我们浏览器页面刷新率是60hz，也就意味着16.67ms就要刷新一次。

## 题外话，setTimeout

setTimeout是浏览器环境提供的WebApi，大致用法是延时执行。但实际意义不是多久之后执行，而是**最快多久之后执行**。

如下列代码

```js
setTimeout(() => {
    task()
},3000)

sleep(10000000)
```

实际执行并不是3秒后执行task()，而是需要更长时间，实际执行过程如下

- task()进入Event Table并注册，浏览器使用计时器线程计时
- 执行sleep函数，执行非常慢，计时线程继续工作
- 3秒到了，计时事件完成，task()移入Event Queue，但是sleep函数没有执行完，调用栈不为空，继续等待
- 又过了许久，sleep执行完毕，调用栈为空，从宏任务队列取出task()执行

所以经常遇到的`setTimeout(fn,0)`这样的代码，指定某个任务在主线程最早可得的空闲时间执行。意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行

> 关于`setTimeout`要补充的是，即便主线程为空，0毫秒实际上也是达不到的。根据HTML的标准，最低是4毫秒。

## 题外话，setInterval

`setTimeout`的孪生兄弟`setInterval`。两者差不多，只不过后者是循环的执行。对于执行顺序来说，`setInterval`会每隔指定的时间将注册的函数置入Event Queue，如果前面的任务耗时太久，那么同样需要等待。

唯一需要注意的一点是，对于`setInterval(fn,ms)`来说，我们已经知道不是每过`ms`秒会执行一次`fn`，而是每过`ms`秒，会有`fn`进入Event Queue。一旦**`setInterval`的回调函数`fn`执行时间超过了延迟时间`ms`，那么就完全看不出来有时间间隔了**。当`fn`执行完时，任务队列中已经有处于就绪态,等待调用栈空执行的`fn`

## async/await

`async`关键字是将一个同步函数变成一个异步函数，并将返回值变为`promise`。

而`await`可以放在任何异步的、基于`promise`的函数之前。在执行过程中，它会暂停代码在该行上，直到`promise`完成，然后返回结果值。而在暂停的同时，其他正在等待执行的代码就有机会执行了。

> 个人理解简单来说：await之后的函数如果不是返回promise，那么就相当于同步函数，如果是异步函数，就会将后面的函数先执行完，然后将后面的代码都加入到微任务队列中去，具体例子看下文的掘金帖子

## 举个例子

[掘金帖子例子非常详细](https://juejin.cn/post/6969028296893792286#comment)

## 最后总结

1. **JS是单线程语言**，不管是什么新框架新语法糖实现的所谓异步，其实都是用同步的方法去模拟的，牢牢把握住单线程这点非常重要。
2. **事件循环是js实现异步的一种方法，也是js的执行机制。**
3. 执行和运行有很大的区别，JavaScript在不同的环境下，比如node，浏览器，Ringo等等，执行方式是不同的。而运行大多指JavaScript解析引擎，是统一的。

